# Ingenieria y calidad de software (repaso)

[Caso TANGO APP](https://www.notion.so/Caso-TANGO-APP-1ea9386c67d18079892be4fa3a7340d2?pvs=21)

[Caso de Body Painting](https://www.notion.so/Caso-de-Body-Painting-1ee9386c67d1806ea064da7fe055ac1b?pvs=21)

Que es la Ingenieria de software?

La ingenieria de software es el conjunto de procedimientos, herramientas que se encargan de la produccion del software, desde la adquisicion de requerimientos hasta el mantenimiento del mismo.

Es importante ya que:

- Las empresas necesitan software de mayor calidad y más barato.
- Resulta más barato crear un buen sistema al inicio que crearlo de cero todo el tiempo.

Hay 3 realidades:

- El diseño es esencial
- Es importante entender el problema muy bien en un inicio para poder mejorarlo.
- Hacer un buen diseño generara mejor calidad y mantenibilidad

¿Cuál es el estado actual?

Respuesta 1 Mati:

El estado actual está muy avanzado, algunos de los items son:

- Orientacion a Sistemas Distribuidos y en la nube.
- Muchisimos Frameworks, tecnologias, lenguajes especializados para cada area.
- Enfoque en la mantenibilidad y escalabilidad.
- Existe un amplio desarrollo del Hardware que requiere que se aproveche muy bien con un buen Software que acompañe.
- Enfoque en Inteligencias Artificiales con soluciones con predicciones.
- Cada vez hay más especializacion de desarrolladores IT.

Respuesta 2 ChatGPT:

El estado actual del software está altamente evolucionado, con un fuerte enfoque en sistemas distribuidos y arquitecturas en la nube. El desarrollo moderno prioriza la escalabilidad, la mantenibilidad y la eficiencia, impulsado por una gran variedad de frameworks y lenguajes especializados según el dominio (por ejemplo, React para interfaces, Python para ciencia de datos, y Go para microservicios).

Además, el auge de la inteligencia artificial ha traído soluciones predictivas y automatizadas en muchas industrias. El hardware, cada vez más potente, exige software optimizado que lo aproveche al máximo. También ha crecido la especialización de los desarrolladores y la adopción de prácticas DevOps, junto con un enfoque fuerte en la seguridad y la ética del software.

En resumen, el software actual es una combinación de tecnología de punta, pensamiento sistémico y responsabilidad social.

### Razones de la crisis del software

Los antecedentes del software son:

- Gran aumento de la complejidad, no eran simples programas, sino que era software especializado para grandes entidades claves tales como empresas, gobierno o militares que requerian sistemas más solidos.
- Falta de metodologias: Antes dependia todo del programador y de la creatividad de este. Era como un programador sin brujula, requerian una forma de organizarse, sostenerse y saber cuando y como actuar. No habia proceso de Analisis y Diseño.
- Falta de Desarrolladores especializados: Habia poca formacion en este nuevo mercado, muchos no estaban preparados para proyectos grandes y complejos, la demanda aumento mas que la cantidad de estos.
- Subestimacion del esfuerzo: Se creia que desarrollar Software era mas facil que construir Hardware, por lo cual se prometian plazos irreales con presupuestos bajos.
- Baja calidad y errores frecuentes: Se entregaban programas con bugs y dificiles de mantener.

### Disciplinas que conforman la Ingenieria del Software

- Disciplinas Tecnicas:
- Pasos
    - Toma de requerimientos
    - Analisis de Requerimientos
    - Diseño
    - Implementacion
    - Prueba
    - Despliegue
    - Documentacion
    - Capacitacion de Usuarios
- Disciplinas de Gestion: Todo lo encargado a la planificacion, monitorio, y control de la vida del proyecto, se utilizan metodologias LEAN Agile por ejemplo.
- Disciplinas de Soporte: Son disciplinas transversales que permiten verificar la integridad y calidad del software:
    - SCM
    - Toma de metricas
    - Aseguramiento de calidad (QA - Quality Assurance
    

## Ciclos de vida

Es la serie de pasos por la cual un producto o proyecto progresa con el tiempo.

El ciclo de vida define

- Elementos del proceso (actividades, tareas)
- Flujo de proceso (como esos elementos se relacionan y el orden de esos elementos)

Son modelos genericos que permiten saber si se debe pasar al siguiente paso o no

### Administracion de proyectos dependiendo del ciclo de vida

La administracion depende del modelo de ciclo de vida, si se analizan los requerimientos y se observa que estos pueden cambiar mucho durante el tiempo se eligiria un modelo mas flexible como el iterativo. Si es un proyecto simple con requerimientos bien definidos un modelo en cascada sería más util. Entonces la planificacion y la administracion se ve afectada por la eleccion del ciclo de vida

### Que es un proceso de desarrollo de Software

Es el conjunto de metodos, practicas, actividades y sus productos asociados. Las actividades del proceso de desarrollo estan determinadas por la eleccion del ciclo de vida.

Los 3 factores son:

- Personas motivadas
- Procedimientos y metodos
- Herramientas y equipo

### Componentes de un proyecto de Sistemas de Informacion

# Proyecto

Un proyecto es un esfuerzo temporal que realiza un equipo a partir de un acuerdo con la promesa de cumplir la creacion de un servicio, producto o resultado unico

Las caracteristicas es que son unicos y los resultados van a ser unicos e irrepetibles.

Es orientada a objetivos, los objetivos deben ser medibles, alcanzables, no ambiguos. Y los proyectos deben tener una fecha de inicio y un fin. Librando a las personas y los recursos.

## Administracion de proyecto de Software

Organizacion y coordinacion de las personas y recursos que permiten desarrollar el producto en tiempo, forma y con las funcionalidad acordadas con el cliente.

Esto incluye la: Planificacion, Monitoreo y control.

Las metas más importantes son:

- Entregar el producto en tiempo acordado
- Ajustarse al presupuesto
- Entregar software que cumpla con las expectativas
- Mantener al equipo en desarrollo optimo

Hay una triple restriccion que es el alcance, tiempo y costo

## Lider del proyecto

Es la persona encarga de asignar las tareas y manejar las relaciones con los stakeholders

Las habilidades blandas que posee son:

- motivacion
- organizacion
- innovacion
- empatia
- comunicacion
- liderazgo

Las habilidades duras son:

- Resolucion de problemas
- Identidad administrativa
- Logro: recompensa la iniciativa y los logros
- Influencia

## Equipo de proyecto

### Stakeholders

### Plan de proyecto

Establece que se va a hacer, cuando y como y quien lo va a hacer.

Cuenta con las siguientes actividades

1. Definicion del alcance de proyecto

el alcance del proyecto define todo el trabajo y solo el trabajo necesario que se
debe realizar para cumplir con el desarrollo de este y poder entregar el producto o servicio con todas las características
y funciones especificadas. El alcance del proyecto se mide contra el Plan de Proyecto (objetivos del proyecto).

1. Definicion de procesos y ciclo de vida

Al definir el proceso que se va a utilizar, se responde al cómo se va a desarrollar el proyecto. Es importante tener en
cuenta la información del contexto del desarrollo: objetivos, alcances, personas y recursos disponibles, clientes, forma
de trabajo de personas, etc. Por ejemplo, no es lo mismo utilizar un proceso y ciclos de vida para trabajos presenciales
que remotos.

1. Estimacion

En un proyecto de desarrollo de software, se trata de estimar para predecir el valor de un elemento relacionado con
el proyecto o con el producto, por ejemplo, el tiempo que va a llevar, qué costo va a tener el sistema, cuántas personas
necesito para realizar el desarrollo, etc. En un enfoque tradicional, esta estimación de valores es realizada únicamente
por el líder de proyecto. En la metodología tradicional, existe un orden definido y recomendado para realizar las
estimaciones:

1. Gestion de riesgos
2. Asignacion de recursos
3. Programacion de proyectos
4. Definicion de metricas
5. Definicion de controles

# Testing

El testing es una actividad para el control de calidad.

El **testing**, o **pruebas de software**, es un proceso fundamental en el desarrollo de software que consiste en **evaluar y verificar** que un producto o aplicación de software funcione como se espera y cumpla con los requisitos especificados.

En esencia, el objetivo del testing es **encontrar errores, defectos o fallas** en el software antes de que sea entregado o puesto en producción. Al identificar y corregir estos problemas de manera temprana, se busca garantizar la **calidad, confiabilidad y correcto funcionamiento** del software.

### Principios

- el testing muestra presencia de defecto
- El testing exhaustivo es imposible
- Agrupamiento de defectos
- Un programador deberia evitar probar su propio codigo

### Diferencia entre error y defecto

- El **error** es la **metedura de pata** del humano.
- El **defecto** es la **consecuencia** de esa metedura de pata en el software.

Un **defecto** es la **manifestación** de un error en el software. Es un problema o imperfección en el código, diseño, documentación o cualquier otro artefacto del software que puede causar que el sistema no funcione como se espera.

Un **error** es una **acción humana** que produce un resultado incorrecto. Es la equivocación cometida por alguien durante el proceso de desarrollo, ya sea al escribir el código, diseñar la arquitectura, especificar los requisitos o incluso al configurar el entorno.

El error es la **causa potencial** de que algo no funcione correctamente en el software.

- **Ejemplos de errores:**
    - Un desarrollador escribe mal una línea de código.
    - Un analista malinterpreta un requisito del cliente.
    - Un diseñador crea una interfaz de usuario confusa.
    - Un administrador de sistemas configura incorrectamente un servidor.

Un defecto me sale más caro que arreglar un error

Los defectos se clasifican por severidad: (Bloqueante, Critico, Mayor, Menor, Cosmetico) y prioridad (urgente, alta, media, baja)

### Niveles de prueba

Pruebas de componente

Pruebas de integracion

Pruebas de sistema

Pruebas de aceptacion

**Pruebas de Componente (o Pruebas Unitarias):**

- **Objetivo:** Verificar la funcionalidad correcta de las unidades o componentes individuales del software. Una "unidad" puede ser una función, un método, una clase o un módulo pequeño.
- **Enfoque:** Se realizan de forma aislada, sin depender de otros componentes del sistema. A menudo, se utilizan "stubs" (simuladores) y "mocks" (objetos falsos con comportamiento predefinido) para aislar la unidad bajo prueba de sus dependencias.
- **Quién las realiza:** Generalmente, los desarrolladores son los principales responsables de escribir y ejecutar las pruebas unitarias.
- **Beneficios:**
    - Detección temprana de errores a nivel de código.
    - Facilita la depuración y el refactoring (reestructuración del código).
    - Proporciona documentación viva del comportamiento de las unidades.
    - Aumenta la confianza en el código base.
    - Reduce los costos de corrección de errores en etapas posteriores.
- **Ejemplo:** Probar una función específica que calcula el descuento en un carrito de compras, asegurándose de que funcione correctamente con diferentes entradas (porcentaje de descuento, valor del carrito, etc.).

**2. Pruebas de Integración:**

- **Objetivo:** Verificar la interacción y la correcta comunicación entre los diferentes componentes o unidades que se han probado individualmente. Se busca asegurar que los módulos trabajen juntos como se espera.
- **Enfoque:** Se prueban las interfaces entre los componentes, el flujo de datos y el control entre ellos. Se pueden realizar de forma incremental, integrando y probando grupos de componentes relacionados.
- **Quién las realiza:** Generalmente, los testers (probadores) o los desarrolladores trabajan en las pruebas de integración.
- **Beneficios:**
    - Detección de errores en las interfaces entre componentes.
    - Asegura que los diferentes módulos se complementen y funcionen en conjunto.
    - Revela problemas relacionados con la integración de diferentes partes del sistema.
- **Ejemplo:** Probar la interacción entre el módulo de gestión de usuarios y el módulo de gestión de pedidos, asegurándose de que cuando un usuario realiza un pedido, la información se guarda correctamente en ambos módulos.

**3. Pruebas de Sistema:**

- **Objetivo:** Evaluar el sistema completo e integrado. Se prueban todos los componentes trabajando juntos como un todo para verificar que cumpla con los requisitos funcionales y no funcionales especificados.
- **Enfoque:** Se simulan escenarios de uso reales por parte de los usuarios finales. Se prueban aspectos como la funcionalidad, el rendimiento, la seguridad, la usabilidad y la confiabilidad del sistema en su conjunto.
- **Quién las realiza:** Principalmente, los testers (probadores) son responsables de las pruebas de sistema.
- **Beneficios:**
    - Verifica que el sistema cumpla con los requisitos del usuario y del negocio.
    - Detecta problemas que solo surgen cuando todos los componentes están integrados.
    - Evalúa la calidad general del sistema desde la perspectiva del usuario.
- **Ejemplo:** Probar el flujo completo de compra en una tienda online, desde la selección de productos hasta el pago y la confirmación del pedido, verificando que todos los pasos funcionen correctamente y que se cumplan los requisitos de seguridad y rendimiento.

**4. Pruebas de Aceptación:**

- **Objetivo:** Determinar si el sistema cumple con las necesidades y expectativas de los stakeholders (usuarios finales, clientes, etc.) y si están dispuestos a aceptarlo. Las realiza el stakeholder
- **Enfoque:** Se realizan en un entorno que se asemeja al entorno de producción. A menudo, son los propios usuarios finales o representantes del cliente quienes ejecutan estas pruebas, utilizando escenarios de uso reales y desde su perspectiva.
- **Quién las realiza:** Los usuarios finales, los clientes o representantes del cliente son los principales participantes en las pruebas de aceptación.
- **Beneficios:**
    - Asegura que el sistema cumple con las expectativas del cliente.
    - Genera confianza y aceptación por parte de los stakeholders.
    - Proporciona la aprobación final para la liberación del sistema.
- **Tipos comunes:**
    - **Pruebas de Aceptación del Usuario (UAT):** Realizadas por los usuarios finales.
    - **Pruebas de Aceptación Operacional (OAT):** Se centran en la preparación del sistema para su operación y mantenimiento (instalación, copias de seguridad, recuperación, etc.).
    - **Pruebas de Aceptación por Contrato:** Verifican que el sistema cumpla con los criterios de aceptación definidos en un contrato.
- **Ejemplo:** En una aplicación bancaria, los clientes podrían realizar pruebas de aceptación para verificar que pueden realizar transferencias, consultar saldos y generar informes de manera intuitiva y correcta.

Estas pruebas se realizan de a niveles, es decir, antes de hacer una prueba de integracion se realizan pruebas de componentes, antes de hacer pruebas de sistema se hacen pruebas de integracion y antes de hacer pruebas de sistema se realizan pruebas de aceptacion.

Ejemplo:

Prueba de componentes: Funcion que realiza el descuento.

Prueba de Integracion: Sistema de cobro.

Prueba de Sistema: Sistema de ventas online.

Prueba de Aceptacion: Prueba que realiza el stakeholder sobre el sistema.

### Ambiente de desarrollo

El ambiente de desarrollo es la ubicacion de la “rama” principal de la aplicacion de software. Esta es donde los desarrolladores gastan mas tiempo escribiendo las primeras lineas de codigo. Desde aqui, la aplicacion se transforma desde el concepto, en papel, en el MVP.

### Ambiente de prueba

Cuando se reserva un servidor entero (o un contenedor) para correr test ininterrumpidamente, se dice que se ha creado un ambiente de prueba. Tipicamente, un ambiente de prueba reune los requerimientos minimos para que la aplicacion funcione. Se pueden hacer pruebas de integracion y de sistema

- Residir en un computador distinto del personal de desarrollo
- Utilizar nombres de dominio distintos a lso de desarrollo para evitar confusion por parte del personal
- Ser lo mas similar al ambiente de produccion
- Instalar las herramientas que se van a utilizar para testear en un servidor dedicado que pueda ser accedido por todo el equipo de prueba
- Debe apoyarse en herramientas de control de versiones.

### El ambiente de pre-produccion

es cuando se crea una instancia de la aplicacion que se tiene confianza suficiente para mostrarla a los stakeholders pero no a los usuarios finales. No se lo muestra a los usuarios finales debido a que se pueden llegar a realizar mas test

### Ambiente de produccion

Como usuario final, cuando se requiere hacer uso de la pagina web o la aplicacion movil, dicha aplicacion está corriendo en un server de produccion.

### Proceso de prueba

Está formado por planificacion y control, analisis y diseño, ejecucion, evaluacion y reportes.

### Estrategias de prueba

Se basa en maximizar la cantidad de errores encontrados con menor esfuerzo posible (+cobertura, -costo)

Caja blanca: 

La **estrategia de prueba de caja blanca** (también conocida como **white-box testing**, **glass-box testing** o **prueba estructural**) es un enfoque de testing que se centra en **examinar la estructura interna, el diseño y la implementación del software**. El tester que aplica esta estrategia tiene **conocimiento del código fuente** y utiliza ese conocimiento para diseñar casos de prueba.

En esencia, en la prueba de caja blanca, se trata de **"mirar dentro de la caja"** del software para entender cómo funciona internamente y así poder probar los caminos de ejecución, las condiciones, los bucles y la lógica del código.

**Técnicas comunes:**

- **Cobertura de sentencias:** Asegurar que cada línea de código ejecutable se pruebe al menos una vez.
- **Cobertura de decisiones (o de ramas):** Asegurar que cada posible resultado de una condición (verdadero o falso) se pruebe al menos una vez.
- **Cobertura de condiciones:** Asegurar que todas las condiciones lógicas dentro de una decisión se prueben con todos sus posibles valores.
- **Cobertura de caminos:** Asegurar que todos los posibles caminos de ejecución a través de una función o un programa se prueben al menos una vez.
- **Cobertura de bucles:** Probar los bucles con diferentes números de iteraciones (cero, una, varias veces).
- **Análisis de flujo de datos:** Examinar cómo los datos fluyen a través del programa y asegurar que se manipulan correctamente.
- **Pruebas basadas en la sintaxis:** Verificar la correcta sintaxis y estructura del código.

la **cobertura de caja negra** se enfoca en **probar la funcionalidad del software desde una perspectiva externa, sin conocimiento de su estructura interna, diseño o implementación**.

En la estrategia de prueba de caja negra, el tester interactúa con el software de la misma manera que lo haría un usuario final. Se concentra en **qué hace el software**, en lugar de **cómo lo hace**. Los casos de prueba se diseñan basándose en los **requisitos funcionales, las especificaciones y la interfaz de usuario** del software.

Aquí te presento los aspectos clave de la cobertura de caja negra:

**Características Principales:**

- **Sin conocimiento del código fuente:** El tester no necesita tener acceso ni entender el código interno del software.
- **Énfasis en la funcionalidad:** Se centra en probar si el software cumple con las funciones y los comportamientos esperados según las especificaciones.
- **Perspectiva del usuario:** Se simulan escenarios de uso reales desde el punto de vista del usuario final.
- **Objetivo:** Verificar que el software funcione correctamente según los requisitos del usuario y del negocio.
- **Niveles de prueba:** Se aplica en todos los niveles de prueba, pero es especialmente relevante en las pruebas de sistema y las pruebas de aceptación. También se utiliza en las pruebas de componente y de integración para verificar la funcionalidad expuesta por las unidades y las interfaces.
- **Técnicas comunes:**
    - **Partición de equivalencia:** Dividir los datos de entrada en grupos (particiones) que se espera que sean tratados de la misma manera por el software. Se selecciona un valor representativo de cada partición para la prueba.
    - **Análisis de valores límite:** Probar los valores en los bordes de las particiones de equivalencia, ya que estos suelen ser puntos donde los errores son más comunes.
    - **Pruebas basadas en la tabla de decisiones:** Utilizar tablas de decisiones para probar diferentes combinaciones de condiciones y sus resultados correspondientes.
    - **Pruebas basadas en casos de uso:** Diseñar pruebas que sigan los flujos de trabajo o escenarios de uso típicos de los usuarios.
    - **Pruebas basadas en el dominio:** Utilizar el conocimiento del dominio de la aplicación para diseñar pruebas relevantes.
    - **Pruebas exploratorias:** Un enfoque menos estructurado donde el tester aprende sobre el software a medida que lo prueba, diseñando nuevas pruebas en función de sus hallazgos.
    - **Pruebas basadas en modelos:** Utilizar modelos del comportamiento del software para diseñar casos de prueba.
    - **Pruebas basadas en riesgos:** Priorizar las pruebas de las funcionalidades que tienen mayor riesgo de fallar o que tendrían un mayor impacto si fallaran.

**Beneficios de la Prueba de Caja Negra:**

- **Perspectiva del usuario real:** Asegura que el software funcione como se espera desde el punto de vista del usuario final.
- **Independencia del desarrollo:** Los testers no necesitan conocimientos técnicos internos del software, lo que permite una perspectiva más objetiva.
- **Adecuado para todos los niveles de prueba:** Se puede aplicar en cualquier etapa del proceso de testing.
- **Útil para probar la interfaz de usuario:** Se centra en la facilidad de uso y la correcta interacción con la interfaz.
- **Puede revelar problemas de especificación:** Al probar la funcionalidad esperada, se pueden identificar inconsistencias o ambigüedades en los requisitos.

**Desventajas de la Prueba de Caja Negra:**

- **Cobertura incompleta:** Sin conocimiento de la estructura interna, es posible que no se prueben todos los caminos de ejecución o todas las condiciones del código.
- **Ineficiencia potencial:** Se pueden diseñar casos de prueba redundantes o que no cubran áreas críticas del código.
- **Dificultad para identificar la causa raíz de los errores:** Cuando una prueba falla, puede ser más difícil determinar la causa del problema sin conocer el código interno.
- **Dependencia de la calidad de las especificaciones:** La efectividad de las pruebas de caja negra depende en gran medida de la claridad y la precisión de los requisitos y las especificaciones.

El **análisis de valores límite** (también conocido como **boundary value analysis** o **BVA**) es otra técnica de diseño de casos de prueba de **caja negra** que se enfoca en **probar los valores que se encuentran en los bordes o límites de las clases de equivalencia** que identificamos previamente.

La idea detrás del análisis de valores límite es que los errores en el software tienden a ocurrir con mayor frecuencia en los límites de los rangos de entrada o salida. Esto se debe a menudo a errores de "off-by-one" (desfase de uno) en la lógica de programación (por ejemplo, usar `<` en lugar de `<=`).

La **partición de equivalencia** es una técnica de diseño de casos de prueba de **caja negra** que busca **reducir el número de casos de prueba necesarios** al dividir el conjunto de datos de entrada posibles en **grupos (particiones)** que se espera que sean tratados de la misma manera por el software.

La idea fundamental detrás de la partición de equivalencia es que si una condición dentro de una partición funciona correctamente, entonces es razonable asumir que todas las demás condiciones dentro de la misma partición también funcionarán correctamente. De esta manera, en lugar de probar cada valor individualmente, solo necesitamos probar un valor representativo de cada partición.

### Que es el testing funcional

El **testing funcional** es un tipo de prueba de software de **caja negra** que se centra en **verificar si el software cumple con las funcionalidades y los requisitos especificados desde la perspectiva del usuario final**. En otras palabras, se trata de probar **"qué hace"** el software, sin importar **"cómo lo hace"** internamente.
Basada en requerimientos, y basado en los procesos de negocio.

### El testing no funcional

Se centran en el “como” y no “el que”

- Pruebas de performance (pruebas de carga, o stress)
- Pruebas de usabilidad (pruebas con usuarios reales, se basa en UX/UI)
- Pruebas de mantenimiento (adaptacion al cambio)
- Pruebas de fiabilidad (Que tan bien una aplicacion proporciona un servicio que se establecio en las especificaciones)
- Pruebas de portabilidad (funcionamiento en diferentes plataformas).
- Pruebas de configuracion (Compatibilidad con drivers, hardware, etc)

### Test Driven Devolpment

El **Test-Driven Development (TDD)**, o **Desarrollo Guiado por Pruebas**, es una metodología de desarrollo de software que **invierte el orden tradicional** en el que se escribe el código y las pruebas. En lugar de escribir primero el código y luego las pruebas para verificarlo, con TDD **primero se escriben las pruebas (que inicialmente fallan) y luego se escribe el código mínimo necesario para que esas pruebas pasen**.

Este ciclo se repite de forma continua y se conoce como el ciclo **"Red-Green-Refactor"**:

1. **Red (Escribir una prueba que falla):**
    - Se comienza escribiendo una **prueba automatizada** para una funcionalidad específica que aún no se ha implementado.
    - Esta prueba debe ser muy precisa y definir claramente qué se espera que haga el código.
    - Al no existir el código aún, la prueba **fallará** (de ahí el color "rojo").
2. **Green (Escribir el código mínimo para pasar la prueba):**
    - A continuación, se escribe la **cantidad mínima de código necesaria** para que la prueba previamente escrita pase.
    - El objetivo en esta etapa es simplemente hacer que la prueba deje de fallar ("volverse verde").
    - No se debe escribir código adicional ni pensar en la arquitectura general en este punto.
3. **Refactor (Mejorar el código):**
    - Una vez que la prueba pasa, se revisa el código recién escrito y el código existente para **mejorar su estructura, legibilidad, eficiencia y diseño**, sin alterar su comportamiento (es decir, todas las pruebas deben seguir pasando).
    - Esto incluye eliminar duplicación, mejorar nombres de variables y métodos, y aplicar principios de diseño.

Este ciclo se repite para cada pequeña unidad de funcionalidad del software.

**Principios Fundamentales de TDD:**

- **Escribir pruebas antes del código:** Esta es la piedra angular de TDD.
- **Escribir pruebas pequeñas y enfocadas:** Cada prueba debe verificar un aspecto específico y bien definido de la funcionalidad.
- **Ejecutar las pruebas con frecuencia:** Las pruebas deben ejecutarse después de cada cambio para asegurar que el código sigue funcionando correctamente.
- **Mantener las pruebas simples y legibles:** Las pruebas deben ser fáciles de entender para que sirvan como documentación viva del comportamiento del código.
- **Cubrir todos los aspectos importantes:** A través de la repetición del ciclo, se busca construir una suite de pruebas exhaustiva que cubra todas las funcionalidades del software.

**Beneficios del Test-Driven Development:**

- **Mejor diseño del código:** Al pensar primero en cómo se va a probar el código, se tiende a escribir código más modular, cohesivo y fácil de probar.
- **Mayor confianza en el código:** Una suite de pruebas exhaustiva proporciona una gran confianza en que el código funciona correctamente y que los cambios futuros no introducirán regresiones.
- **Documentación viva:** Las pruebas automatizadas actúan como una forma de documentación ejecutable que describe cómo se espera que se comporte el código.
- **Reducción de errores:** Al probar el código de forma continua y en pequeñas unidades, se detectan los errores de forma temprana y se reduce la probabilidad de tener errores complejos en etapas posteriores.
- **Desarrollo más enfocado:** El ciclo Red-Green-Refactor ayuda a mantener el enfoque en la funcionalidad actual y evita la tendencia a escribir código innecesario.
- **Refactoring más seguro:** La suite de pruebas proporciona una red de seguridad al realizar refactorizaciones, permitiendo verificar rápidamente que los cambios no han roto la funcionalidad existente.

**Desventajas del Test-Driven Development:**

- **Curva de aprendizaje:** Requiere un cambio de mentalidad y práctica para los desarrolladores acostumbrados al desarrollo tradicional.
- **Puede llevar más tiempo inicialmente:** Escribir las pruebas antes del código puede parecer que ralentiza el proceso al principio. Sin embargo, a largo plazo, la reducción de errores y la mejora del diseño suelen compensar este tiempo.
- **No es adecuado para todos los tipos de proyectos:** Puede ser más difícil de aplicar en proyectos con requisitos muy vagos o en interfaces de usuario complejas.
- **Las pruebas deben ser buenas:** Si las pruebas están mal escritas, pueden dar una falsa sensación de seguridad o no cubrir aspectos importantes del código.